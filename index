<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; margin: 0; }
        input, button, textarea, select { margin: 5px; padding: 5px; }
        .grid-container { display: grid; grid-template-columns: repeat(202, 1fr); gap: 10px; overflow-x: auto; }
        .column { display: flex; flex-direction: column; }
        textarea { width: 100%; height: 300px; resize: vertical; }
        .chart-container { 
            margin-top: 20px; 
            height: 1000px; /* Increased height for better visibility */
            width: 100%; 
            position: relative; 
            overflow: hidden; 
        }
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
            max-height: 1000px; /* Match the increased container height */
            object-fit: contain;
        }
        #statsContainer { margin-top: 20px; }
        #generalStatsContainer { margin-top: 20px; }
        #summaryContainer { margin-top: 20px; }
        .sensor-id { display: flex; align-items: center; }
        .sensor-id span { flex-shrink: 0; margin-right: 5px; }
        .drop-zone {
            border: 2px dashed #ccc;
            padding: 10px;
            color: #999;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
        }
        .drop-zone.highlight {
            background-color: #e8f5e9;
            border-color: #4caf50;
        }
        canvas {
            border: 1px solid #ccc;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 150mm;
            margin-bottom: 50mm;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            text-align: justify;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f4f4f4;
        }
        .image-upload {
            margin: 20px 0;
            padding: 10px;
        }
        .image-upload label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>
<div id="inputControls">
    <!-- Seletor de Tipo de Dados -->
    <select id="dataType" onchange="toggleLimits()">
        <option value="temp">Temperatura (°C)</option>
        <option value="humid">Umidade Relativa (%UR)</option>
        <option value="both">Temperatura e Umidade</option>
    </select>

    <!-- Limites de Temperatura -->
    <div id="tempLimits">
        <input type="number" id="LI_temp" placeholder="Limite Inferior Temperatura">
        <input type="number" id="LS_temp" placeholder="Limite Superior Temperatura">
    </div>

    <!-- Limites de Umidade -->
    <div id="humidLimits" style="display:none;">
        <input type="number" id="LI_humid" placeholder="Limite Inferior Umidade">
        <input type="number" id="LS_humid" placeholder="Limite Superior Umidade">
    </div>

    <!-- Seleção de Testes -->
    <select id="testType">
        <option value="semCarga">Distribuição térmica sem carga</option>
        <option value="comCarga">Distribuição térmica com carga</option>
        <option value="comCargaRota">Distribuição térmica com carga em rota</option>
        <option value="aberturaPorta">Abertura de porta</option>
        <option value="quedaEnergia">Queda de energia</option>
    </select>

    <!-- Campo de Observações -->
    <div>
        <label for="observations">Observações:</label>
        <input type="text" id="observations" placeholder="Insira suas observações aqui..." style="width: 33%;">
    </div>

    <!-- Seleção do Formato de Data -->
    <div>
        <label for="dateFormat">Formato de Data:</label>
        <select id="dateFormat">
            <option value="portuguese">Português (DD-MM-YY HH:MM:SS)</option>
            <option value="english" selected>Inglês (YYYY-MM-DD HH:MM:SS)</option>
        </select>
    </div>

    <!-- Outros controles existentes -->
    <div>
        <input type="datetime-local" id="startDate" placeholder="Data/Hora Inicial">
        <label><input type="checkbox" id="allDatesFlag" checked> Considerar todos os dados</label>
    </div>
    <input type="datetime-local" id="endDate" placeholder="Data/Hora Final">
</div>

<!-- Campo para upload do Croqui -->
<div class="image-upload">
    <label for="croqui">Croqui de distribuição:</label>
    <input type="file" id="croqui" accept="image/*">
</div>

<div class="grid-container">
    <div class="column">
        <input type="text" value="Data/Hora" readonly>
        <textarea id="column0" placeholder="Cole os dados de Data/Hora aqui"></textarea>
    </div>
    <div class="column">
        <div class="sensor-id"><span>S EXT:</span><input type="text" id="sensorEXT" placeholder="ID do Sensor"></div>
        <textarea id="columnEXT" placeholder="Cole os dados aqui"></textarea>
        <div class="drop-zone" id="dropzoneEXT">Arraste e solte o arquivo aqui</div>
    </div>
    <script>
<script>
    const gridContainer = document.querySelector('.grid-container');

    for (let i = 1; i <= 200; i++) {
        const column = document.createElement('div');
        column.className = 'column';

        column.innerHTML = `
            <div class="sensor-id">
                <span>S${i}:</span>
                <input type="text" id="sensor${i}" placeholder="ID do Sensor">
            </div>
            <textarea id="column${i}" placeholder="Cole os dados aqui"></textarea>
            <div class="drop-zone" id="dropzone${i}">Arraste e solte o arquivo aqui</div>
        `;

        gridContainer.appendChild(column);
    }
</script>

</div>

<!-- Seus botões -->
<button onclick="generateCharts()">Gerar Gráficos</button>
<button onclick="chooseFileFormat()">Baixar Relatório</button>

<table id="tempTable"></table>
<table id="humidTable"></table>
<table id="generalStatsTableTemp"></table>
<table id="generalStatsTableHumid"></table>

<div id="printArea">
    <div class="chart-container" id="chartContainerTemp">
        <canvas id="myChartTemp"></canvas>
    </div>

    <div id="tempStatsTableContainer">
        <table id="tempTable"></table>
    </div>

    <table id="generalStatsTableTemp"></table>

    <div class="chart-container" id="chartContainerHumid">
        <canvas id="myChartHumid"></canvas>
    </div>

    <div id="humidStatsTableContainer">
        <table id="humidTable"></table>
    </div>

    <table id="generalStatsTableHumid"></table>

    <div class="print-section" id="statsContainer"></div>
    <div class="print-section" id="generalStatsContainer"></div>
    <div class="print-section" id="summaryContainer"></div>
</div>

<script>
    let chartTemp = null;  // Variável global para o gráfico de temperatura
    let chartHumid = null;  // Variável global para o gráfico de umidade

    // Função para converter data com base no formato selecionado
    function parseCustomDate(dateStr) {
        // Verifica se dateStr é uma string válida
        if (!dateStr || typeof dateStr !== 'string') {
            return null;
        }

        dateStr = dateStr.trim();
        const dateFormat = document.getElementById('dateFormat').value;

        if (dateFormat === 'portuguese') {
            // Formato Português: DD-MM-YY HH:MM:SS (ex.: 18-02-25 15:41:55)
            const match = dateStr.match(/(\d{2})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (match) {
                const day = match[1];
                const month = match[2];
                const year = match[3];
                const hours = match[4];
                const minutes = match[5];
                const seconds = match[6];
                // Assume que YY < 70 é 20XX, senão 19XX
                const fullYear = parseInt(year) < 70 ? `20${year}` : `19${year}`;
                return new Date(`${fullYear}-${month}-${day}T${hours}:${minutes}:${seconds}`);
            }
        } else if (dateFormat === 'english') {
            // Formato Inglês: YYYY-MM-DD HH:MM:SS (ex.: 2025-02-24 09:13:20)
            const match = dateStr.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (match) {
                const year = match[1];
                const month = match[2];
                const day = match[3];
                const hours = match[4];
                const minutes = match[5];
                const seconds = match[6];
                return new Date(`${year}-${month}-${day}T${hours}:${minutes}:${seconds}`);
            }
        }

        return null;
    }

    // Função para alternar os limites (Temperatura ou Umidade)
    function toggleLimits() {
        const dataType = document.getElementById('dataType').value;
        const tempLimits = document.getElementById('tempLimits');
        const humidLimits = document.getElementById('humidLimits');

        if (dataType === 'temp') {
            tempLimits.style.display = 'block';
            humidLimits.style.display = 'none';
        } else if (dataType === 'humid') {
            tempLimits.style.display = 'none';
            humidLimits.style.display = 'block';
        } else if (dataType === 'both') {
            tempLimits.style.display = 'block';
            humidLimits.style.display = 'block';
        }
    }

    // Função para gerar gráficos
    function generateCharts() {
        const LI_temp = parseFloat(document.getElementById('LI_temp').value);
        const LS_temp = parseFloat(document.getElementById('LS_temp').value);
        const LI_humid = parseFloat(document.getElementById('LI_humid').value);
        const LS_humid = parseFloat(document.getElementById('LS_humid').value);
        const dataType = document.getElementById('dataType').value;

        const fontConfig = {
            family: 'Arial',
            size: 18,
            weight: 'bold',
            color: '#000000'
        };

        const axisConfig = {
            ticks: {
                font: {
                    size: 18,
                    weight: 'bold'
                },
                color: '#000000'
            },
            title: {
                display: true,
                font: {
                    size: 14,
                    weight: 'bold'
                },
                color: '#000000'
            }
        };

        // Obter e validar labels (datas)
        let labels = document.getElementById('column0').value.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');
        if (labels.length === 0) {
            alert("Não há dados de Data/Hora válidos para gerar o gráfico.");
            return;
        }

        // Aplicar filtro de data se necessário
        const allDatesFlag = document.getElementById('allDatesFlag').checked;
        let filteredLabels = labels;
        let startDate, endDate;

        if (!allDatesFlag) {
            const startDateStr = document.getElementById('startDate').value;
            const endDateStr = document.getElementById('endDate').value;

            // O datetime-local retorna no formato YYYY-MM-DDThh:mm
            startDate = startDateStr ? new Date(startDateStr) : null;
            endDate = endDateStr ? new Date(endDateStr) : null;

            if (!startDate || !endDate || isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                alert("Por favor, insira datas válidas de início e fim.");
                return;
            }

            // Filtrar labels por data
            filteredLabels = labels.filter(dateStr => {
                const currentDate = parseCustomDate(dateStr);
                return currentDate && currentDate >= startDate && currentDate <= endDate;
            });

            if (filteredLabels.length === 0) {
                alert("Não há dados no intervalo de datas selecionado.");
                return;
            }
        }

        let tempData = [];
        let humidData = [];
        let datasetsTemp = [];
        let datasetsHumid = [];
        const colors = [
            'rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)',
            'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'
        ];

        function getRandomColor(index) {
            return colors[index % colors.length];
        }

        // Processar dados do sensor externo
        const sensorEXTId = document.getElementById('sensorEXT').value.trim();
        let sensorEXTData = document.getElementById('columnEXT').value.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');
        const sensorEXTDisplay = sensorEXTId ? `S EXT: ${sensorEXTId}` : 'S EXT';

        // Aplicar filtro de data aos dados do sensor externo
        if (!allDatesFlag) {
            sensorEXTData = sensorEXTData.filter((_, index) => {
                const currentDate = parseCustomDate(labels[index]);
                return currentDate && currentDate >= startDate && currentDate <= endDate;
            });
        }

        if (sensorEXTData.length > 0) {
            if (dataType === 'temp') {
                const sensorEXTTempData = sensorEXTData.map(val => parseFloat(val.replace(',', '.')));
                datasetsTemp.push({
                    label: sensorEXTDisplay,
                    data: sensorEXTTempData,
                    borderColor: 'rgba(0, 0, 0, 1)',
                    borderWidth: 3, // Increased line thickness
                    yAxisID: 'yTemp',
                    fill: false
                });
            } else if (dataType === 'humid') {
                const sensorEXTHumidData = sensorEXTData.map(val => parseFloat(val.replace(',', '.')));
                datasetsHumid.push({
                    label: sensorEXTDisplay,
                    data: sensorEXTHumidData,
                    borderColor: 'rgba(0, 0, 0, 1)',
                    borderWidth: 3, // Increased line thickness
                    yAxisID: 'yHumid',
                    fill: false
                });
            } else if (dataType === 'both') {
                const sensorEXTBothData = sensorEXTData.map(row => row.split('|').map(val => parseFloat(val.replace(',', '.'))));
                const sensorEXTTempData = sensorEXTBothData.map(row => row[0]);
                const sensorEXTHumidData = sensorEXTBothData.map(row => row[1]);

                datasetsTemp.push({
                    label: sensorEXTDisplay,
                    data: sensorEXTTempData,
                    borderColor: 'rgba(0, 0, 0, 1)',
                    borderWidth: 3, // Increased line thickness
                    yAxisID: 'yTemp',
                    fill: false
                });

                datasetsHumid.push({
                    label: sensorEXTDisplay,
                    data: sensorEXTHumidData,
                    borderColor: 'rgba(0, 0, 0, 1)',
                    borderWidth: 3, // Increased line thickness
                    yAxisID: 'yHumid',
                    fill: false
                });
            }
        }

        // Processar dados dos sensores S1-S200
        for (let i = 1; i <= 200; i++) {
            const sensorId = document.getElementById(`sensor${i}`).value.trim();
            let columnData = document.getElementById(`column${i}`).value.trim();

            if (sensorId && columnData) {
                columnData = columnData.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');

                // Aplicar filtro de data aos dados do sensor
                if (!allDatesFlag) {
                    columnData = columnData.filter((_, index) => {
                        const currentDate = parseCustomDate(labels[index]);
                        return currentDate && currentDate >= startDate && currentDate <= endDate;
                    });
                }

                const sensorDisplay = `S${i}: ${sensorId}`;

                if (dataType === 'both') {
                    const tempAndHumid = columnData.map(row => row.split('|').map(value => parseFloat(value.trim())));
                    let tempDataSet = tempAndHumid.map(row => row[0]);
                    let humidDataSet = tempAndHumid.map(row => row[1]);

                    tempData.push(tempDataSet);
                    humidData.push(humidDataSet);

                    datasetsTemp.push({
                        label: sensorDisplay,
                        data: tempDataSet,
                        borderColor: getRandomColor(i),
                        borderWidth: 3, // Increased line thickness
                        yAxisID: 'yTemp',
                        fill: false
                    });

                    datasetsHumid.push({
                        label: sensorDisplay,
                        data: humidDataSet,
                        borderColor: getRandomColor(i + 100),
                        borderWidth: 3, // Increased line thickness
                        yAxisID: 'yHumid',
                        fill: false
                    });
                } else if (dataType === 'temp') {
                    const data = columnData.map(val => parseFloat(val.replace(',', '.')));
                    tempData.push(data);

                    datasetsTemp.push({
                        label: sensorDisplay,
                        data: data,
                        borderColor: getRandomColor(i),
                        borderWidth: 3, // Increased line thickness
                        yAxisID: 'yTemp',
                        fill: false
                    });
                } else if (dataType === 'humid') {
                    const data = columnData.map(val => parseFloat(val.replace(',', '.')));
                    humidData.push(data);

                    datasetsHumid.push({
                        label: sensorDisplay,
                        data: data,
                        borderColor: getRandomColor(i),
                        borderWidth: 3, // Increased line thickness
                        yAxisID: 'yHumid',
                        fill: false
                    });
                }
            }
        }

        // Adicionar limites aos datasets
        if (dataType === 'temp' || dataType === 'both') {
            datasetsTemp.push({
                label: 'Limite Inferior Temperatura',
                data: Array(filteredLabels.length).fill(LI_temp),
                borderColor: 'rgba(0, 0, 255, 1)',
                borderDash: [5, 5],
                borderWidth: 3, // Increased line thickness
                fill: false
            });
            datasetsTemp.push({
                label: 'Limite Superior Temperatura',
                data: Array(filteredLabels.length).fill(LS_temp),
                borderColor: 'rgba(255, 0, 0, 1)',
                borderDash: [5, 5],
                borderWidth: 3, // Increased line thickness
                fill: false
            });
        }

        if (dataType === 'humid' || dataType === 'both') {
            datasetsHumid.push({
                label: 'Limite Inferior Umidade',
                data: Array(filteredLabels.length).fill(LI_humid),
                borderColor: 'rgba(0, 0, 255, 1)',
                borderDash: [5, 5],
                borderWidth: 3, // Increased line thickness
                fill: false
            });
            datasetsHumid.push({
                label: 'Limite Superior Umidade',
                data: Array(filteredLabels.length).fill(LS_humid),
                borderColor: 'rgba(255, 0, 0, 1)',
                borderDash: [5, 5],
                borderWidth: 3, // Increased line thickness
                fill: false
            });
        }

        // Limpar gráficos anteriores
        if (chartTemp) chartTemp.destroy();
        if (chartHumid) chartHumid.destroy();

        // Criar gráfico de temperatura
        const ctxTemp = document.getElementById('myChartTemp').getContext('2d');
        chartTemp = new Chart(ctxTemp, {
            type: 'line',
            data: {
                labels: filteredLabels,
                datasets: datasetsTemp
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Gráfico de Temperatura',
                        font: {
                            size: 38,
                            weight: 'bold',
                            color: '#000000'
                        },
                        color: '#000000'
                    },
                    legend: {
                        display: false,
                        position: 'top',
                        labels: {
                            font: fontConfig,
                            color: '#000000',
                            boxWidth: 20,
                            padding: 10
                        }
                    }
                },
                scales: {
                    yTemp: {
                        ...axisConfig,
                        type: 'linear',
                        position: 'left',
                        title: {
                            ...axisConfig.title,
                            text: 'Temperatura (°C)'
                        }
                    },
                    x: {
                        ...axisConfig,
                        title: {
                            ...axisConfig.title,
                            text: 'Data/Hora'
                        }
                    }
                }
            }
        });

        // Criar gráfico de umidade se necessário
        if (dataType === 'both' || dataType === 'humid') {
            const ctxHumid = document.getElementById('myChartHumid').getContext('2d');
            chartHumid = new Chart(ctxHumid, {
                type: 'line',
                data: {
                    labels: filteredLabels,
                    datasets: datasetsHumid
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Gráfico de Umidade',
                            font: {
                                size: 38,
                                weight: 'bold',
                                color: '#000000'
                            },
                            color: '#000000'
                        },
                        legend: {
                            display: false,
                            position: 'top',
                            labels: {
                                font: fontConfig,
                                color: '#000000',
                                boxWidth: 20,
                                padding: 10
                            }
                        }
                    },
                    scales: {
                        yHumid: {
                            ...axisConfig,
                            type: 'linear',
                            position: 'left',
                            title: {
                                ...axisConfig.title,
                                text: 'Umidade (%)'
                            }
                        },
                        x: {
                            ...axisConfig,
                            title: {
                                ...axisConfig.title,
                                text: 'Data/Hora'
                            }
                        }
                    }
                }
            });
        }

        // Gerar tabelas
        generateTables(tempData, humidData, filteredLabels, LI_temp, LS_temp, LI_humid, LS_humid);

    }

   
















function chooseFileFormat() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4', compress: true });
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margins = { top: 10, bottom: 10, left: 10, right: 10 };
    const pdfWidth = pageWidth - margins.left - margins.right;

    const dataType = document.getElementById('dataType').value;
    const testType = document.getElementById('testType').value;
    const croquiInput = document.getElementById('croqui');
    const analysisNames = {
        semCarga: "Distribuição térmica sem carga",
        comCarga: "Distribuição térmica com carga",
        comCargaRota: "Distribuição térmica com carga em rota",
        aberturaPorta: "Abertura de porta",
        quedaEnergia: "Queda de energia"
    };
    const analysisName = analysisNames[testType] || "Teste não identificado";
    const observationsCapa = document.getElementById('observations')?.value?.trim() || '';

    const addPageNumbering = (doc) => {
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            doc.setPage(i);
            doc.setFontSize(10);
            const pageText = `Página ${i} de ${totalPages}`;
            const textWidth = doc.getTextWidth(pageText);
            doc.text(pageText, (pageWidth - textWidth) / 2, pageHeight - margins.bottom);
        }
    };

    const renderChartToPDF = async (canvasId) => {
        const chart = document.getElementById(canvasId);
        if (chart) {
            const canvas = await html2canvas(chart, { scale: 2 });
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            const imgProps = doc.getImageProperties(imgData);
            const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;

            doc.addPage();
            doc.addImage(imgData, 'JPEG', margins.left, margins.top, pdfWidth, imgHeight);
        }
    };

    const renderImageToPDF = async (inputId) => {
        const input = document.getElementById(inputId);
        return new Promise((resolve) => {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const imgData = e.target.result;
                    const imgProps = doc.getImageProperties(imgData);
                   doc.addPage();

		   const maxWidth = pageWidth - margins.left - margins.right;
		   const maxHeight = pageHeight - margins.top - margins.bottom;

		   let imgWidth = imgProps.width;
		   let imgHeight = imgProps.height;

		   const ratio = Math.min(maxWidth / imgWidth, maxHeight / imgHeight);

		   imgWidth *= ratio;
		   imgHeight *= ratio;

		   const x = (pageWidth - imgWidth) / 2;
		   const y = (pageHeight - imgHeight) / 2;

		   doc.addImage(imgData, 'JPEG', x, y, imgWidth, imgHeight);

                    resolve(true);
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                resolve(false);
            }
        });
    };

    const renderTableToPDF = (tableId, title, addNewPage = true) => {
        const table = document.getElementById(tableId);
        if (table && table.rows.length > 0) {
            if (addNewPage) doc.addPage();
            doc.autoTable({
                html: table,
                startY: margins.top,
                margin: { left: margins.left, right: margins.right },
                styles: { fontSize: 10, cellPadding: 2, halign: 'center', textColor: [0, 0, 0] },
                headStyles: { fillColor: [0, 176, 146], textColor: 255, fontStyle: 'bold' },
                theme: 'grid',
                pageBreak: 'auto',
                showHead: 'everyPage'
            });
        }
    };

    // Página 1 - Capa
    doc.setFontSize(28);
    doc.text(`Dados brutos do teste de\n${analysisName}`, pageWidth / 2, pageHeight / 3, { align: 'center' });
    if (observationsCapa) {
        doc.setFontSize(14);
        doc.text(`Observações:\n${observationsCapa}`, pageWidth / 2, pageHeight / 2, { align: 'center' });
    }

    (async () => {
        await renderChartToPDF('myChartTemp');

        if ((dataType === 'humid' || dataType === 'both') && document.getElementById('myChartHumid')?.clientHeight > 0) {
            await renderChartToPDF('myChartHumid');
        }

        if (croquiInput.files.length > 0) {
            await renderImageToPDF('croqui');
        }

        renderTableToPDF('tempTable', '');

        if ((dataType === 'humid' || dataType === 'both') && document.getElementById('humidTable')?.rows.length > 0) {
            renderTableToPDF('humidTable', '');
        }

        const tempTable = document.getElementById('generalStatsTableTemp');
        const humidTable = document.getElementById('generalStatsTableHumid');
        if ((tempTable && tempTable.rows.length > 0) || (humidTable && humidTable.rows.length > 0)) {
            doc.addPage();
            doc.autoTable({
                html: tempTable,
                startY: margins.top,
                margin: { left: margins.left, right: margins.right },
                styles: { fontSize: 10, textColor: [0, 0, 0], cellPadding: 2, halign: 'center' },
                headStyles: { fillColor: [0, 176, 146], textColor: 255, fontStyle: 'bold' },
                theme: 'grid',
                pageBreak: 'auto',
                showHead: 'everyPage'
            });

            doc.autoTable({
                html: humidTable,
                startY: doc.lastAutoTable.finalY + 10,
                margin: { left: margins.left, right: margins.right },
                styles: { fontSize: 10, textColor: [0, 0, 0], cellPadding: 2, halign: 'center' },
                headStyles: { fillColor: [0, 176, 146], textColor: 255, fontStyle: 'bold' },
                theme: 'grid',
                pageBreak: 'auto',
                showHead: 'everyPage'
            });
        }

        doc.addPage();

        const limiteInferiorTemp = parseFloat(document.getElementById('LI_temp').value) || 0;
        const limiteSuperiorTemp = parseFloat(document.getElementById('LS_temp').value) || 0;
        const limiteInferiorHumid = parseFloat(document.getElementById('LI_humid').value) || 0;
        const limiteSuperiorHumid = parseFloat(document.getElementById('LS_humid').value) || 0;

        if (dataType === 'both') {
            addDataTables(doc, limiteInferiorTemp, limiteSuperiorTemp, limiteInferiorHumid, limiteSuperiorHumid);
        } else if (dataType === 'temp') {
            addDataTables(doc, limiteInferiorTemp, limiteSuperiorTemp);
        } else {
            addDataTables(doc, limiteInferiorHumid, limiteSuperiorHumid);
        }

        addPageNumbering(doc);
        doc.save(`relatorio_${testType.toLowerCase()}.pdf`);
    })();
}
















    // Função para adicionar as tabelas de dados nas páginas subsequentes
    function addDataTables(doc, limiteInferiorTemp, limiteSuperiorTemp, limiteInferiorHumid, limiteSuperiorHumid) {
        const dataType = document.getElementById('dataType').value;
        const headers = [['Data/Hora']];
        let columnsWithData = [];
        const dataHoraColumn = document.getElementById('column0').value.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');

        const sExtElement = document.getElementById('columnEXT');
        const sExtData = sExtElement.value.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');

        const allDatesFlag = document.getElementById('allDatesFlag').checked;
        let startDate = null;
        let endDate = null;

        if (!allDatesFlag) {
            const startDateStr = document.getElementById('startDate').value;
            const endDateStr = document.getElementById('endDate').value;
            startDate = startDateStr ? new Date(startDateStr) : null;
            endDate = endDateStr ? new Date(endDateStr) : null;
            if (!startDate || !endDate || isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                alert("Por favor, insira datas válidas de início e fim.");
                return;
            }
        }

        function isInRange(dateTime) {
            const currentDate = parseCustomDate(dateTime);
            return allDatesFlag || (currentDate && currentDate >= startDate && currentDate <= endDate);
        }

        const filteredDataHora = dataHoraColumn.filter(isInRange);

        if (sExtData.length > 0) {
            headers[0].push('S EXT');
            columnsWithData.push(sExtData.filter((_, index) => isInRange(dataHoraColumn[index])));
        }

        for (let i = 1; i <= 200; i++) {
            const sensorId = document.getElementById(`sensor${i}`).value.trim();
            const columnElement = document.getElementById(`column${i}`).value.trim();

            if (sensorId && columnElement) {
                const columnData = columnElement.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');
                headers[0].push(`S${i} ${sensorId}`);
                columnsWithData.push(columnData.filter((_, index) => isInRange(dataHoraColumn[index])));
            }
        }

        const maxColumnsPerPage = 15;
        let startColumnIndex = 0;

        while (startColumnIndex < columnsWithData.length) {
            const endColumnIndex = Math.min(startColumnIndex + maxColumnsPerPage, columnsWithData.length);
            const pageHeaders = [['Data/Hora'].concat(headers[0].slice(startColumnIndex + 1, endColumnIndex + 1))];
            const pageBody = [];

            for (let rowIndex = 0; rowIndex < filteredDataHora.length; rowIndex++) {
                const row = [filteredDataHora[rowIndex]];
                let hasValidData = false;

                for (let colIndex = startColumnIndex; colIndex < endColumnIndex; colIndex++) {
                    let cellData = columnsWithData[colIndex][rowIndex] || '';

                    if (cellData.trim() !== '') {
                        if (dataType === 'both') {
                            const [temp, humid] = cellData.split('|').map(value => value.trim());
                            const tempFormatted = temp ? parseFloat(temp).toFixed(1) : '';
                            const humidFormatted = humid ? parseFloat(humid).toFixed(1) : '';
                            row.push(`${tempFormatted} | ${humidFormatted}`);
                        } else {
                            cellData = parseFloat(cellData).toFixed(1);
                            row.push(cellData);
                        }
                        hasValidData = true;
                    } else {
                        row.push('');
                    }
                }

                if (hasValidData) {
                    pageBody.push(row);
                }
            }

            if (pageBody.length > 0) {
                doc.autoTable({
                    head: pageHeaders,
                    body: pageBody,
                    startY: 20,
                    styles: {
                        fontSize: 8,
                        cellPadding: 1,
                        lineWidth: 0.1,
                        halign: 'center',
                        textColor: [0, 0, 0]
                    },
                    theme: 'grid',
                    margin: { bottom: 20 },
                    tableLineColor: [200, 200, 200],
                    tableLineWidth: 0.1,
                    didParseCell: function(data) {
                        if (data.section === 'head' || data.column.index === 0) {
                            return;
                        }

                        const value = data.cell.raw;
                        if (!value) return;

                        if (dataType === 'both' && value.includes('|')) {
                            const [tempStr, humidStr] = value.split('|').map(v => v.trim());
                            const tempValue = parseFloat(tempStr);
                            const humidValue = parseFloat(humidStr);

                            if (!isNaN(tempValue)) {
                                if (tempValue > limiteSuperiorTemp || (humidValue && humidValue > limiteSuperiorHumid)) {
                                    data.cell.styles.textColor = [255, 0, 0];
                                } else if (tempValue < limiteInferiorTemp || (humidValue && humidValue < limiteInferiorHumid)) {
                                    data.cell.styles.textColor = [0, 0, 255];
                                }
                            }
                        } else {
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue)) {
                                if (dataType === 'temp') {
                                    if (numValue > limiteSuperiorTemp) {
                                        data.cell.styles.textColor = [255, 0, 0];
                                    } else if (numValue < limiteInferiorTemp) {
                                        data.cell.styles.textColor = [0, 0, 255];
                                    }
                                } else if (dataType === 'humid') {
                                    if (numValue > limiteSuperiorHumid) {
                                        data.cell.styles.textColor = [255, 0, 0];
                                    } else if (numValue < limiteInferiorHumid) {
                                        data.cell.styles.textColor = [0, 0, 255];
                                    }
                                }
                            }
                        }
                    }
                });

                if (endColumnIndex < columnsWithData.length) {
                    doc.addPage('a4', 'landscape');
                }
            }
            startColumnIndex = endColumnIndex;
        }
    }

    function generateTables(tempData, humidData, labels, LI_temp, LS_temp, LI_humid, LS_humid) {
        const tempTable = document.getElementById('tempTable');
        const humidTable = document.getElementById('humidTable');
        const generalStatsTableTemp = document.getElementById('generalStatsTableTemp');
        const generalStatsTableHumid = document.getElementById('generalStatsTableHumid');

        if (!tempTable || !humidTable || !generalStatsTableTemp || !generalStatsTableHumid) {
            console.error("Um ou mais elementos da tabela não foram encontrados no HTML.");
            return;
        }

        tempTable.innerHTML = '';
        humidTable.innerHTML = '';
        generalStatsTableTemp.innerHTML = '';
        generalStatsTableHumid.innerHTML = '';

        function calcStatistics(data, LI, LS) {
            const validData = data.filter(value => !isNaN(value));
            if (validData.length === 0) {
                return { min: NaN, max: NaN, avg: NaN, belowSpec: 0, withinSpec: 0, aboveSpec: 0 };
            }

            const min = Math.min(...validData);
            const max = Math.max(...validData);
            const avg = (validData.reduce((a, b) => a + b, 0) / validData.length).toFixed(2);
            const belowSpec = ((validData.filter(val => val < LI).length / validData.length) * 100).toFixed(2);
            const withinSpec = ((validData.filter(val => val >= LI && val <= LS).length / validData.length) * 100).toFixed(2);
            const aboveSpec = ((validData.filter(val => val > LS).length / validData.length) * 100).toFixed(2);

            return { min, max, avg, belowSpec, withinSpec, aboveSpec };
        }

        function generateIndividualStatsTable(data, LI, LS, targetTable, title, unit) {
            const testType = document.getElementById('testType').value;
            const dataType = document.getElementById('dataType').value;
            const allDatesFlag = document.getElementById('allDatesFlag').checked;
            let startDate = null;
            let endDate = null;

            if (!allDatesFlag) {
                const startDateStr = document.getElementById('startDate').value;
                const endDateStr = document.getElementById('endDate').value;
                startDate = startDateStr ? new Date(startDateStr) : null;
                endDate = endDateStr ? new Date(endDateStr) : null;
            }

            const tableHeader = `
                <thead>
                    <tr>
                        <th colspan="7">${title}</th>
                    </tr>
                    <tr>
                        <th>Sensor</th>
                        <th>Mínima (${unit})</th>
                        <th>Média (${unit})</th>
                        <th>Máxima (${unit})</th>
                        <th>% Abaixo da Especificação</th>
                        <th>% Dentro da Especificação</th>
                        <th>% Acima da Especificação</th>
                    </tr>
                </thead>`;

            let minSensors = [];
            let maxSensors = [];
            let minTemp = Infinity;
            let maxTemp = -Infinity;
            let sensorsWithData = [];

            const dates = document.getElementById('column0').value.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');

            for (let i = 1; i <= 200; i++) {
                const columnData = document.getElementById(`column${i}`).value.trim();
                const sensorId = document.getElementById(`sensor${i}`).value.trim();

                if (columnData && sensorId) {
                    let rawData = columnData.split('\n').filter(line => line && typeof line === 'string' && line.trim() !== '');
                    let filteredData = [];

                    for (let j = 0; j < rawData.length; j++) {
                        if (dates[j]) {
                            const currentDate = parseCustomDate(dates[j]);
                            if (allDatesFlag || (currentDate && currentDate >= startDate && currentDate <= endDate)) {
                                if (dataType === 'both') {
                                    const [temp, humid] = rawData[j].split('|').map(v => parseFloat(v.trim()));
                                    filteredData.push(unit === '°C' ? temp : humid);
                                } else {
                                    filteredData.push(parseFloat(rawData[j]));
                                }
                            }
                        }
                    }

                    filteredData = filteredData.filter(value => !isNaN(value));

                    if (filteredData.length > 0) {
                        const sensorStats = calcStatistics(filteredData, LI, LS);
                        const sensorInfo = {
                            id: i,
                            display: `S${i}: ${sensorId}`,
                            stats: sensorStats,
                            avg: parseFloat(sensorStats.avg)
                        };

                        sensorsWithData.push(sensorInfo);

                        if (!isNaN(sensorStats.min)) {
                            if (sensorStats.min < minTemp) {
                                minTemp = sensorStats.min;
                                minSensors = [sensorInfo];
                            } else if (sensorStats.min === minTemp) {
                                minSensors.push(sensorInfo);
                            }
                        }

                        if (!isNaN(sensorStats.max)) {
                            if (sensorStats.max > maxTemp) {
                                maxTemp = sensorStats.max;
                                maxSensors = [sensorInfo];
                            } else if (sensorStats.max === maxTemp) {
                                maxSensors.push(sensorInfo);
                            }
                        }
                    }
                }
            }

            sensorsWithData.sort((a, b) => a.id - b.id);

            const tableBody = sensorsWithData.map(sensor => `
                <tr>
                    <td>${sensor.display}</td>
                    <td>${isNaN(sensor.stats.min) ? 'N/A' : sensor.stats.min.toFixed(2)}</td>
                    <td>${isNaN(sensor.stats.avg) ? 'N/A' : sensor.stats.avg}</td>
                    <td>${isNaN(sensor.stats.max) ? 'N/A' : sensor.stats.max.toFixed(2)}</td>
                    <td>${sensor.stats.belowSpec} %</td>
                    <td>${sensor.stats.withinSpec} %</td>
                    <td>${sensor.stats.aboveSpec} %</td>
                </tr>`
            ).join('');

            let note = '';
            
            if ((testType === 'comCarga' || testType === 'semCarga') && minSensors.length > 0 && maxSensors.length > 0) {
                let minSensor = minSensors.length > 1 
                    ? minSensors.reduce((a, b) => a.avg < b.avg ? a : b)
                    : minSensors[0];
                let maxSensor = maxSensors.length > 1
                    ? maxSensors.reduce((a, b) => a.avg > b.avg ? a : b)
                    : maxSensors[0];

                if (unit === '°C') {
                    note = `<tr><td colspan="7" style="text-align: left; padding: 10px;">
                        Nota: Para a definição do ponto mais frio, foi levado em consideração o ponto do dispositivo de medição com registro de menor temperatura mínima, sendo este, o sensor ${minSensor.display} (${minTemp.toFixed(2)}°C) e para a definição do ponto mais quente, foi levado em consideração o sensor com maior registro máximo de temperatura, sendo este o sensor ${maxSensor.display} (${maxTemp.toFixed(2)}°C). Em casos de registros de mínima e ou máxima iguais, o critério de definição leva em consideração a média do dispositivo de medição.
                    </td></tr>`;
                } else if (unit === '%UR') {
                    note = `<tr><td colspan="7" style="text-align: left; padding: 10px;">
                        Nota: Para a definição do ponto menos úmido, foi levado em consideração o ponto do dispositivo de medição com registro de menor umidade mínima, sendo este, o sensor ${minSensor.display} (${minTemp.toFixed(2)}%UR) e para a definição do ponto mais úmido, foi levado em consideração o sensor com maior registro máximo de umidade relativa, sendo este o sensor ${maxSensor.display} (${maxTemp.toFixed(2)}%UR). Em casos de registros de mínima e ou máxima iguais, o critério de definição leva em consideração a média do dispositivo de medição.
                    </td></tr>`;
                }
            }

            targetTable.innerHTML = tableHeader + '<tbody>' + tableBody + note + '</tbody>';
        }

        function generateGeneralStatsTable(data, LI, LS, targetTable, title, unit) {
            function processData(data) {
                if (!Array.isArray(data)) return [];
                
                return data.map(row => {
                    if (typeof row === 'string' && row.includes('|')) {
                        const [temp, humid] = row.split('|').map(v => parseFloat(v.trim()));
                        return unit === '°C' ? temp : humid;
                    }
                    return parseFloat(row);
                }).filter(v => !isNaN(v));
            }

            const processedData = data.map(sensorData => processData(sensorData));
            const allData = processedData.flat();
            const stats = calcStatistics(allData, LI, LS);

            const numRows = processedData[0]?.length || 0;
            let sumMin = 0;
            let sumMax = 0;
            let validRows = 0;

            for (let row = 0; row < numRows; row++) {
                let rowValues = [];
                for (let sensorIndex = 0; sensorIndex < processedData.length; sensorIndex++) {
                    const value = processedData[sensorIndex][row];
                    if (!isNaN(value)) {
                        rowValues.push(value);
                    }
                }

                if (rowValues.length > 0) {
                    sumMin += Math.min(...rowValues);
                    sumMax += Math.max(...rowValues);
                    validRows++;
                }
            }

            const avgMin = validRows > 0 ? sumMin / validRows : NaN;
            const avgMax = validRows > 0 ? sumMax / validRows : NaN;

            const tableHeader = `
                <thead>
                    <tr>
                        <th colspan="8">${title}</th>
                    </tr>
                    <tr>
                        <th>Mínima (${unit})</th>
                        <th>Média (${unit})</th>
                        <th>Máxima (${unit})</th>
                        <th>Média Mínima (${unit})</th>
                        <th>Média Máxima (${unit})</th>
                        <th>% Abaixo da Especificação</th>
                        <th>% Dentro da Especificação</th>
                        <th>% Acima da Especificação</th>
                    </tr>
                </thead>`;
            
            const tableBody = `
                <tbody>
                    <tr>
                        <td>${isNaN(stats.min) ? 'N/A' : stats.min.toFixed(2)}</td>
                        <td>${isNaN(stats.avg) ? 'N/A' : stats.avg}</td>
                        <td>${isNaN(stats.max) ? 'N/A' : stats.max.toFixed(2)}</td>
                        <td>${isNaN(avgMin) ? 'N/A' : avgMin.toFixed(2)}</td>
                        <td>${isNaN(avgMax) ? 'N/A' : avgMax.toFixed(2)}</td>
                        <td>${stats.belowSpec} %</td>
                        <td>${stats.withinSpec} %</td>
                        <td>${stats.aboveSpec} %</td>
                    </tr>
                </tbody>`;

            targetTable.innerHTML = tableHeader + tableBody;
        }

        if (tempData && tempData.length > 0) {
            generateIndividualStatsTable(tempData, LI_temp, LS_temp, tempTable, 
                "Estatísticas Individuais por Sensor de Temperatura", "°C");
            generateGeneralStatsTable(tempData, LI_temp, LS_temp, generalStatsTableTemp,
                "Estatísticas Gerais de Temperatura", "°C");
        }

        if (humidData && humidData.length > 0) {
            generateIndividualStatsTable(humidData, LI_humid, LS_humid, humidTable,
                "Estatísticas Individuais por Sensor de Umidade Relativa", "%UR");
            generateGeneralStatsTable(humidData, LI_humid, LS_humid, generalStatsTableHumid,
                "Estatísticas Gerais de Umidade Relativa", "%UR");
        }
    }

    // Funções para arrastar e soltar os arquivos
    function handleDrop(event, id) {
        event.preventDefault();
        const dropZone = event.currentTarget;
        dropZone.classList.remove('highlight');
        const file = event.dataTransfer.files[0];
        const reader = new FileReader();
        
        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, {type: 'array'});
            const sheet = workbook.Sheets[workbook.SheetNames[0]];

            const dataType = document.getElementById('dataType').value;

            let tempRange = 'C30:C20000';
            let humidRange = 'D30:D20000';
            let dateRange = 'B30:B20000';

            if (id === 'column1') {
                const dateData = XLSX.utils.sheet_to_json(sheet, {header: 1, range: dateRange});
                const dateValues = dateData.map(date => date[0]).filter(val => val && typeof val === 'string').join('\n');
                document.getElementById('column0').value = dateValues;
            }

            if (dataType === 'temp') {
                const tempData = XLSX.utils.sheet_to_json(sheet, {header: 1, range: tempRange});
                const tempValues = tempData.map(row => parseFloat(row[0]).toFixed(1)).filter(val => !isNaN(val)).join('\n');
                document.getElementById(id).value = tempValues;
            } else if (dataType === 'humid') {
                const humidData = XLSX.utils.sheet_to_json(sheet, {header: 1, range: humidRange});
                const humidValues = humidData.map(row => parseFloat(row[0]).toFixed(1)).filter(val => !isNaN(val)).join('\n');
                document.getElementById(id).value = humidValues;
            } else if (dataType === 'both') {
                const tempData = XLSX.utils.sheet_to_json(sheet, {header: 1, range: tempRange});
                const humidData = XLSX.utils.sheet_to_json(sheet, {header: 1, range: humidRange});
                const combinedData = tempData.map((tempRow, index) => {
                    const tempValue = tempRow[0] ? parseFloat(tempRow[0]).toFixed(1) : '';
                    const humidValue = humidData[index] && humidData[index][0] ? parseFloat(humidData[index][0]).toFixed(1) : '';
                    return `${tempValue} | ${humidValue}`;
                }).filter(val => val && val !== ' | ').join('\n');

                document.getElementById(id).value = combinedData;
            }

            document.getElementById(id.replace('column', 'sensor')).value = file.name.replace(/\.[^/.]+$/, '').toUpperCase();

        };

        reader.readAsArrayBuffer(file);
    }

    function highlightZone(event) {
        event.preventDefault();
        event.currentTarget.classList.add('highlight');
    }

    function unhighlightZone(event) {
        event.currentTarget.classList.remove('highlight');
    }

    document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.addEventListener('dragover', highlightZone);
        zone.addEventListener('dragleave', unhighlightZone);
        zone.addEventListener('drop', function(event) {
            handleDrop(event, zone.previousElementSibling.id);
        });
    });

    window.addEventListener('dragover', function(e) {
        e.preventDefault();
    }, false);
    window.addEventListener('drop', function(e) {
        e.preventDefault();
    }, false);
</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9277ae848dbadb29',t:'MTc0MzE3MDcxOS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
